策略模式：

    Comparator就是典型的策略模式

    需要一个排序类，对int类型排序 --> 生成了Sorter.sort(int[] a)

    问题：还需要对double排序、对Cat对象排序等
        解决方法1；重载方法 --> Sorter.sort(double[] a)等等方法
            --> 方法越写越多，类越来越大，增加维护难度
            --> 每需要对一个新的进行排序，就会多一个方法

        解决方法2：定义接口(Comparable接口)、定义方法 --> 需要用的类实现该接口，实现方法
            --> 将具体实现放到对应的实现类中
            --> 依旧不够灵活，存在多个属性，都可以排序
            --> 只能修改方法  --> 违反 设计原则：开闭原则(对修改关闭，对扩展开放)

        解决方法3：定义接口(Comparator接口)、定义方法
            -->作为排序方法的参数传入


    意图：定义一系列的算法,把它们一个个封装起来, 并且使它们可相互替换。
    主要解决：在有多种算法相似的情况下，使用 if...else 所带来的复杂和难以维护。

    何时使用：一个系统有许多许多类，而区分它们的只是他们直接的行为。
    如何解决：将这些算法封装成一个一个的类，任意地替换。
    关键代码：实现同一个接口。

    应用实例：
        1、诸葛亮的锦囊妙计，每一个锦囊就是一个策略。
        2、旅行的出游方式，选择骑自行车、坐汽车，每一种旅行方式都是一个策略。
        3、JAVA AWT 中的 LayoutManager。
    优点：
        1、算法可以自由切换。
        2、避免使用多重条件判断。
        3、扩展性良好。
    缺点：
        1、策略类会增多。
        2、所有策略类都需要对外暴露。

    使用场景：
        1、如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。
        2、一个系统需要动态地在几种算法中选择一种。
        3、如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。
    注意事项：如果一个系统的策略多于四个，就需要考虑使用混合模式，解决策略类膨胀的问题。







