策略模式：

    Comparator就是典型的策略模式

    需要一个排序类，对int类型排序 --> 生成了Sorter.sort(int[] a)

    问题：还需要对double排序、对Cat对象排序等
        解决方法1；重载方法 --> Sorter.sort(double[] a)等等方法
            --> 方法越写越多，类越来越大，增加维护难度
            --> 每需要对一个新的进行排序，就会多一个方法

        解决方法2：定义接口(Comparable接口)、定义方法 --> 需要用的类实现该接口，实现方法
            --> 将具体实现放到对应的实现类中
            --> 依旧不够灵活，存在多个属性，都可以排序
            --> 只能修改方法  --> 违反 设计原则：开闭原则(对修改关闭，对扩展开放)

        解决方法3：定义接口(Comparator接口)、定义方法
            -->作为排序方法的参数传入










